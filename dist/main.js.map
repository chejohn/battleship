{"version":3,"file":"main.js","mappings":";;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;ACAsB;AACa;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mDAAmD,kDAAI;AACvD,2BAA2B,kDAAI;AAC/B;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmB;;;;;;;;;;;;;;;;;ACrInB;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC,kBAAkB;AAClB,KAAK;AACL;;AAEc;;;;;;;UC/Bd;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;ACN+C;;AAE/C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,UAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2BAA2B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAE4B","sources":["webpack://battleship/./src/index.scss","webpack://battleship/./src/GameBoardLibrary.js","webpack://battleship/./src/ShipLibrary.js","webpack://battleship/webpack/bootstrap","webpack://battleship/webpack/runtime/define property getters","webpack://battleship/webpack/runtime/hasOwnProperty shorthand","webpack://battleship/webpack/runtime/make namespace object","webpack://battleship/./src/index.js"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport {};","import './index.scss';\nimport {Ship} from './ShipLibrary';\n// ship is represented by an 'o' on the gameboard\n// misssed hits are represented by an 'x' on the gameboard\n// attacked ships are represented by an '*' on the gameboard\n\nconst GameBoard = () => {\n    const gameState = [\n      [null, null, null, null, null, null, null, null, null, null],\n      [null, null, null, null, null, null, null, null, null, null],\n      [null, null, null, null, null, null, null, null, null, null],\n      [null, null, null, null, null, null, null, null, null, null],\n      [null, null, null, null, null, null, null, null, null, null],\n      [null, null, null, null, null, null, null, null, null, null],\n      [null, null, null, null, null, null, null, null, null, null],\n      [null, null, null, null, null, null, null, null, null, null],\n      [null, null, null, null, null, null, null, null, null, null],\n      [null, null, null, null, null, null, null, null, null, null],\n    ];\n    let currentOrientation = 'x';\n    const cachedShips = [];\n    \n    const convertToCoordinates = (dataID) => {\n        let col;\n        let row;\n        if (dataID % 10 === 0) {\n            col = 9;\n            row = dataID/10 - 1;\n        } \n        else {\n            col = (dataID % 10) - 1;\n            row = Math.floor(dataID / 10); \n        }\n        return [row, col];\n    }\n\n    const cacheShipData = (newShip, shipOrientation, originCoordinates) => {\n        let [row, col] = originCoordinates;\n        const cachedCoordinates = [];\n        for (let i = 0; i < newShip.shipLength; i++) {\n            if (i == 0) cachedCoordinates.push(originCoordinates);\n            else {\n                if (shipOrientation === 'x') cachedCoordinates.push([row, ++col]);\n                else cachedCoordinates.push([++row, col]);\n            }\n        }\n        const dataObj = {\n            shipOrientation,\n            ship: newShip,\n            cachedCoordinates\n        }\n        cachedShips.push(dataObj);\n    }\n\n    const validateInput = (originCoordinates, shipLength) => {\n        const [row, col] = originCoordinates;\n        if (currentOrientation === 'x') {\n           if (col + (shipLength - 1) > 9) return false;\n        } \n        else {\n            if (row + (shipLength - 1) > 9) return false;\n        }\n        return true;\n    }\n\n    const placeShip = (dataID, shipLength) => {\n        const originCoordinates = convertToCoordinates(dataID);\n        const validInput = validateInput(originCoordinates, shipLength);\n\n        if (validInput) {\n            let [row, col] = originCoordinates;\n            const shipOrientation = currentOrientation;\n            let newShip;\n            if (shipOrientation === 'x') newShip = Ship(col, shipLength);\n            else newShip = Ship(row, shipLength);\n            cacheShipData(newShip, shipOrientation, originCoordinates);\n            for (let i = 0; i < shipLength; i++) {\n              if (i == 0) gameState[row][col] = 'o';\n              else {\n                if (shipOrientation === 'x') gameState[row][++col] = 'o';\n                else gameState[++row][col] = 'o';\n              }\n            }\n        }\n    }\n\n    const recieveAttack = (dataID) => {\n        const attackCoordinates = convertToCoordinates(dataID);\n        const [row, col] = attackCoordinates;\n        if (gameState[row][col] === null) {\n            gameState[row][col] = 'x';\n        }\n        else if (gameState[row][col] === 'o') {\n            gameState[row][col] = '*';\n            let breakFromOuter = false;\n            for (let shipData of cachedShips) {\n                for (let xyPair of shipData.cachedCoordinates) {\n                    if (JSON.stringify(xyPair) === JSON.stringify(attackCoordinates)) {\n                        const ship = shipData.ship;\n                        if (shipData.shipOrientation === 'x') ship.hit(col);\n                        else ship.hit(row);\n                        breakFromOuter = true;\n                        break;\n                    }\n                }\n                if (breakFromOuter) break;\n            }\n        }\n    }\n\n    const changeOrientation = () => {\n        if (currentOrientation === 'x') currentOrientation = 'y';\n        else currentOrientation = 'x';\n    } \n\n    const fleetDestroyed = () => {\n        for (let shipData of cachedShips) {\n            if (!shipData.ship.isSunk()) return false;\n        }\n        return true;\n    }\n    \n    return {\n        fleetDestroyed,\n        recieveAttack,\n        placeShip,\n        convertToCoordinates,\n        cachedShips,\n        gameState,\n        changeOrientation\n    }\n}\n\nexport {GameBoard};\n\n\n","const ShipProto =  {\n    hit(number) {\n        const shipRepArr = this.shipRep;\n        for(let i = 0; i < shipRepArr.length; i++) {\n            if (shipRepArr[i] === number) {\n                shipRepArr[i] = 'hit';\n            }\n        }\n    },\n    isSunk() {\n        const shipRepArr = this.shipRep;\n        for (let i = 0; i < shipRepArr.length; i++) {\n            if (shipRepArr[i] !== 'hit') return false;\n        }\n        return true;\n    }\n}\n\nconst Ship = (originInt, length) => {\n    const shipLength = length;\n    const shipRep = [];\n    for (let i = 0; i < shipLength; i++) {\n        shipRep.push(originInt);\n        originInt++;\n    }\n    return Object.create(ShipProto, {\n        shipLength: {value: shipLength},\n        shipRep: {value: shipRep}\n    });\n}\n\nexport {Ship};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { GameBoard } from './GameBoardLibrary';\n\nconst Player = (userBoard) => {\n  const attack = (dataID) => {\n    compBoard.recieveAttack(dataID);\n  };\n\n  const rotateShip = () => {\n    userBoard.changeOrientation();\n  };\n\n  const placeGamePiece = (dataID, length) => {\n    userBoard.placeShip(dataID, length);\n  };\n\n  const queryHit = (dataID) => {\n    const [row, col] = userBoard.convertToCoordinates(dataID);\n    if (userBoard.gameState[row][col] === '*') return true;\n    return false;\n  };\n\n  const querySink = (dataID) => {\n    const attackCoordinates = userBoard.convertToCoordinates(dataID);\n    for (let shipData of userBoard.cachedShips) {\n      for (let coordinates of shipData.cachedCoordinates) {\n        if (JSON.stringify(attackCoordinates) === JSON.stringify(coordinates)) {\n          return shipData.ship.isSunk();\n        }\n      }\n    }\n  };\n  return {\n    attack,\n    rotateShip,\n    placeGamePiece,\n    queryHit,\n    querySink,\n  };\n};\n\nconst Computer = (compBoard, user) => {\n  const availableMoves = [];\n  for (let i = 1; i <= 100; i++) {\n    availableMoves.push(i);\n  }\n  const operandData = {\n    operands: [-1, 1, -10, 10],\n    currOperand: null,\n    effectiveOperand: null,\n  };\n  let tempHitAreas = [];\n\n  const validDataID = (hitArea, operand = 0) => {\n    let aleredOperand;\n    if (operand % 10 === 0 || operand % 10 === -0) aleredOperand = operand/10;\n    const [row, col] = compBoard.convertToCoordinates(hitArea);\n  \n    if (operand === 1 || operand === -1) {\n        if (col + operand < 0 || col + operand > 9) return false;\n    }\n    if (operand === 10 || operand === -10) {\n        if (row + aleredOperand < 0 || row + aleredOperand > 9) return false;\n    }\n    for (let move of availableMoves) {\n        if (move === hitArea + operand) return true;\n    }\n    return false;\n  }\n\n  const chooseMove = () => {\n      let dataID;\n      if (tempHitAreas.length < 1) {\n          const randIndex = Math.floor(Math.random() * availableMoves.length);\n          dataID = availableMoves.splice(randIndex, 1)[0];\n      }\n      else if (tempHitAreas.length <= 1) {\n        const operands = operandData.operands;\n        while(!validDataID(tempHitAreas[0], operands[operands.length - 1])) {\n          operands.pop();\n        }\n        operandData.currOperand = operands.pop();\n        dataID = tempHitAreas[0] + operandData.currOperand;\n      } else {\n          if (operandData.effectiveOperand) dataID = tempHitAreas[tempHitAreas.length - 1] + operandData.currOperand;\n          else {\n              operandData.currOperand = -1 * operandData.currOperand;\n              dataID = operandData.currOperand + tempHitAreas[0];\n          }\n          if (!validDataID(dataID)) {\n            operandData.currOperand = -1 * operandData.currOperand;\n            dataID = operandData.currOperand + tempHitAreas[0]; \n          }\n      }\n      for (let i = 0; i < availableMoves.length; i++) {\n          if (availableMoves[i] === dataID) {\n              availableMoves.splice(i, 1);\n              break;\n          }\n      }\n      return dataID;\n  };\n\n  const attack = () => {\n    const dataID = chooseMove();\n    userBoard.recieveAttack(dataID);\n    const hit = user.queryHit(dataID);\n    if (hit) {\n        const sunk = user.querySink(dataID);\n        if (sunk) {\n            operandData.operands = [-1, 1, -10, 10];\n            operandData.currOperand = null;\n            operandData.effectiveOperand = null;\n            tempHitAreas = [];\n        } else {\n            tempHitAreas.push(dataID);\n            if (tempHitAreas.length > 1) operandData.effectiveOperand = true;\n        }\n    }\n    else if (!hit && tempHitAreas.length > 1) operandData.effectiveOperand = false;\n  };\n\n  const rotateShip = () => {\n    if (Math.random() < 0.5) compBoard.changeOrientation();\n  };\n\n  const placeGamePiece = () => {\n    const lengths = [];\n  };\n\n  return {\n    attack,\n    rotateShip,\n    placeGamePiece,\n  };\n};\n\nexport { Player, Computer };\n\n\n\n"],"names":[],"sourceRoot":""}